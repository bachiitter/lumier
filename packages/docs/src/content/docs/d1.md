---
title: D1
description: Cloudflare D1 SQLite database
---

D1 is Cloudflare’s serverless SQLite database. Use it when you need relational data, transactions, and SQL queries directly from Workers.

D1 works well for:

- Application data (users, projects, sessions, etc.)
- Read-heavy workloads with simple relational modeling
- Small-to-medium datasets where SQLite is a good fit

## Basic Usage

```ts
import { $config, Worker, D1 } from "lumier";

export default $config({
  app() {
    return { name: "my-app", protect: ["production"] };
  },
  run() {
    const db = D1("database");

    Worker("api", {
      entry: "src/index.ts",
      bindings: {
        DB: db,
      },
    });
  },
});
```

## Options

```ts
D1("database", {
  primaryLocation: "wnam",    // Primary location hint
  readReplication: true,      // Enable read replicas
});
```

| Option            | Type      | Description                    |
| ----------------- | --------- | ------------------------------ |
| `primaryLocation` | `string`  | Location hint for primary      |
| `readReplication` | `boolean` | Enable read replication        |

### Location Hints

| Value  | Region                 |
| ------ | ---------------------- |
| `wnam` | Western North America  |
| `enam` | Eastern North America  |
| `weur` | Western Europe         |
| `eeur` | Eastern Europe         |
| `apac` | Asia Pacific           |
| `oc`   | Oceania                |

## Querying from a Worker

```ts
// src/index.ts
import { env } from "cloudflare:workers";

export default {
  async fetch(): Promise<Response> {
    const { results } = await env.DB.prepare("SELECT id, name FROM users LIMIT 25").all();
    return Response.json(results);
  },
};
```

## Using Existing Database

Reference a D1 database not managed by Lumier:

```ts
const db = D1.existing("database", {
  id: "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx",
});
```

## Worker Code

```ts
// src/index.ts
import { env } from "cloudflare:workers";

export default {
  async fetch(request: Request): Promise<Response> {
    // Query
    const { results } = await env.DB.prepare(
      "SELECT * FROM users WHERE id = ?"
    ).bind(1).all();

    // Insert
    await env.DB.prepare(
      "INSERT INTO users (name, email) VALUES (?, ?)"
    ).bind("Alice", "alice@example.com").run();

    // Batch
    await env.DB.batch([
      env.DB.prepare("INSERT INTO logs (message) VALUES (?)").bind("Log 1"),
      env.DB.prepare("INSERT INTO logs (message) VALUES (?)").bind("Log 2"),
    ]);

    return Response.json(results);
  },
};
```

## Migrations

Manage schema changes with migrations. A common workflow is using Wrangler’s D1 migration tools:

```bash
# Create migration
wrangler d1 migrations create database create_users

# Apply migrations
wrangler d1 migrations apply database
```

You can also use an ORM like Drizzle:

- [Drizzle](/docs/drizzle)

## Output

```ts
interface D1Output {
  type: "d1";
  name: string;
  databaseId: string;
}
```

## Next Steps

- [Worker](/docs/worker) — Bind D1 to Workers
- [Configuration](/docs/config) — Binding patterns
