/**
 * Type Generation
 *
 * Generates lumier-env.d.ts files that augment `cloudflare:workers` module.
 * This allows using `import { env } from 'cloudflare:workers'` with full type safety.
 *
 * Inspired by Cloudflare Wrangler's type generation:
 * https://github.com/cloudflare/workers-sdk/tree/main/packages/wrangler/src/type-generation
 */

import * as crypto from "node:crypto";
import * as fs from "node:fs/promises";
import * as path from "node:path";
import type { BindingValue, ResourceRegistry } from "../../sdk/index.js";
import { isLinkableResource } from "./utils.js";

// ============================================================================
// Constants
// ============================================================================

const GENERATED_HEADER = "/* eslint-disable */";
const ENV_HEADER_PREFIX = "// Generated by Lumier";

// ============================================================================
// Types
// ============================================================================

interface PackageJson {
  name?: string;
  dependencies?: Record<string, string>;
  devDependencies?: Record<string, string>;
}

interface BindingTypeInfo {
  type: string;
  isCloudflareType: boolean;
  importPath?: string;
  genericType?: string;
}

interface CollectedBindings {
  bindings: Map<string, BindingTypeInfo>;
  durableObjectClasses: Set<string>;
  hasNodejsCompat: boolean;
  stringVars: Set<string>;
}

// ============================================================================
// Identifier Validation
// ============================================================================

const VALID_IDENTIFIER_REGEX = /^[a-zA-Z_$][\w$]*$/;

function isValidIdentifier(key: string): boolean {
  return VALID_IDENTIFIER_REGEX.test(key);
}

function constructTypeKey(key: string): string {
  return isValidIdentifier(key) ? key : `"${key}"`;
}

// ============================================================================
// Hash Utilities
// ============================================================================

function generateHash(content: string): string {
  return crypto.createHash("sha256").update(content).digest("hex").slice(0, 32);
}

function getEnvHeader(hash: string): string {
  return `${ENV_HEADER_PREFIX} (hash: ${hash})`;
}

// ============================================================================
// Type Mapping
// ============================================================================

const CLOUDFLARE_TYPES = new Set([
  "R2Bucket",
  "KVNamespace",
  "D1Database",
  "Queue",
  "VectorizeIndex",
  "DurableObjectNamespace",
  "Fetcher",
  "Hyperdrive",
  "AnalyticsEngineDataset",
  "Ai",
]);

const LINKABLE_TYPE_MAP: Record<string, string> = {
  bucket: "R2Bucket",
  kv: "KVNamespace",
  d1: "D1Database",
  queue: "Queue",
  vectorize: "VectorizeIndex",
  durable_object: "DurableObjectNamespace",
  worker: "Fetcher",
  hyperdrive: "Hyperdrive",
  analytics_engine: "AnalyticsEngineDataset",
};

const MANUAL_BINDING_TYPE_MAP: Record<string, string> = {
  plain_text: "string",
  secret_text: "string",
  json: "unknown",
  ai: "Ai",
  browser: "Fetcher",
  version_metadata: "WorkerVersionMetadata",
  mtls_certificate: "Fetcher",
  service: "Fetcher",
};

function getBindingTypeInfo(value: BindingValue, workerEntry?: string): BindingTypeInfo {
  // String binding - use literal type
  if (typeof value === "string") {
    return { type: JSON.stringify(value), isCloudflareType: false };
  }

  // Linkable resources (R2, KV, D1, etc.)
  if (isLinkableResource(value)) {
    const cfType = LINKABLE_TYPE_MAP[value.type] ?? "unknown";

    // Durable Objects get generic type with class reference
    if (value.type === "durable_object" && workerEntry) {
      const doRef = value._ref as { className: string; scriptName?: string };
      return {
        type: cfType,
        isCloudflareType: true,
        importPath: workerEntry,
        genericType: doRef.className,
      };
    }

    return { type: cfType, isCloudflareType: CLOUDFLARE_TYPES.has(cfType) };
  }

  // Manual bindings
  if ("type" in value) {
    const cfType = MANUAL_BINDING_TYPE_MAP[value.type] ?? "unknown";

    // JSON bindings - try to use literal type
    if (value.type === "json" && "value" in value) {
      try {
        return { type: JSON.stringify(value.value), isCloudflareType: false };
      } catch {
        return { type: "unknown", isCloudflareType: false };
      }
    }

    return { type: cfType, isCloudflareType: CLOUDFLARE_TYPES.has(cfType) };
  }

  return { type: "unknown", isCloudflareType: false };
}

// ============================================================================
// Binding Collection
// ============================================================================

// biome-ignore lint/complexity/noExcessiveCognitiveComplexity: shut up!
function collectBindings(config: ResourceRegistry): CollectedBindings {
  const bindings = new Map<string, BindingTypeInfo>();
  const durableObjectClasses = new Set<string>();
  const stringVars = new Set<string>();
  let hasNodejsCompat = false;

  for (const worker of config.workers) {
    if (worker.options.compatibilityFlags?.includes("nodejs_compat")) {
      hasNodejsCompat = true;
    }

    for (const [key, value] of Object.entries(worker.options.bindings ?? {})) {
      const typeInfo = getBindingTypeInfo(value, worker.options.entry);

      if (typeInfo.genericType) {
        durableObjectClasses.add(typeInfo.genericType);
      }

      // Track string vars for process.env
      if (!typeInfo.isCloudflareType && typeInfo.type !== "unknown") {
        stringVars.add(key);
      }

      const existing = bindings.get(key);
      if (existing) {
        if (existing.type !== typeInfo.type) {
          // Merge non-CF types as union
          if (!(existing.isCloudflareType || typeInfo.isCloudflareType)) {
            bindings.set(key, {
              type: `${existing.type} | ${typeInfo.type}`,
              isCloudflareType: false,
            });
          } else {
            console.warn(`Warning: Binding "${key}" has conflicting types. Using first type.`);
          }
        }
      } else {
        bindings.set(key, typeInfo);
      }
    }
  }

  return { bindings, durableObjectClasses, hasNodejsCompat, stringVars };
}

// ============================================================================
// Content Generation
// ============================================================================

function generateBindingLines(bindings: Map<string, BindingTypeInfo>, outputDir: string, useAny = false): string[] {
  const sortedKeys = Array.from(bindings.keys()).sort();

  return sortedKeys.map((key) => {
    const info = bindings.get(key)!;
    const typeKey = constructTypeKey(key);

    let typeStr: string;
    if (useAny && info.isCloudflareType) {
      typeStr = "any";
    } else if (info.genericType && info.importPath) {
      const relativePath = generateImportSpecifier(outputDir, info.importPath);
      typeStr = `${info.type}<import("${relativePath}").${info.genericType}>`;
    } else {
      typeStr = info.type;
    }

    return `    ${typeKey}: ${typeStr};`;
  });
}

const fileTypeRegex = /\.(ts|tsx|js|jsx|mjs|cjs)$/;

function generateImportSpecifier(outputDir: string, entryPath: string): string {
  const absoluteEntry = path.resolve(entryPath);
  let relative = path.relative(outputDir, absoluteEntry);
  relative = relative.replace(fileTypeRegex, "");
  if (!relative.startsWith(".")) {
    relative = `./${relative}`;
  }
  return relative.split(path.sep).join("/");
}

function generateTypesContent(collected: CollectedBindings, outputDir: string, hasCfTypes: boolean): string {
  const bindingLines = generateBindingLines(collected.bindings, outputDir, !hasCfTypes);

  // Start with linter disable comments for all major linters
  const parts: string[] = [
    GENERATED_HEADER,
    "// @ts-nocheck",
    "/* eslint-disable */",
    "/* prettier-ignore */",
    "/* biome-ignore format: generated file */",
    "/* oxlint-disable */",
  ];

  // Add reference to @cloudflare/workers-types if available
  if (hasCfTypes) {
    parts.push('/// <reference types="@cloudflare/workers-types" />');
  }

  // Generate Cloudflare namespace with Env interface
  parts.push(`
declare namespace Cloudflare {
  interface Env {
${bindingLines.join("\n")}
  }
}

// Env interface for handler pattern
interface Env extends Cloudflare.Env {}

// Augment cloudflare:workers module for global env access
declare module "cloudflare:workers" {
  // The env object provides typed access to bindings
  const env: Cloudflare.Env;
}

declare global {
  interface CloudflareEnv extends Cloudflare.Env {}
}`);

  // Add process.env support for nodejs_compat
  if (collected.hasNodejsCompat && collected.stringVars.size > 0) {
    const varList = Array.from(collected.stringVars)
      .sort()
      .map((v) => `"${v}"`)
      .join(" | ");

    parts.push(`
type StringifyValues<T extends Record<string, unknown>> = {
  [K in keyof T]: T[K] extends string ? T[K] : string;
};

declare namespace NodeJS {
  interface ProcessEnv extends StringifyValues<Pick<Cloudflare.Env, ${varList}>> {}
}`);
  }

  // parts.push("\nexport {};");

  const content = parts.join("\n");
  const hash = generateHash(content);

  return `${getEnvHeader(hash)}\n${content}\n`;
}

function generateReferenceContent(rootEnvPath: string, packageDir: string): string {
  const relativePath = path.relative(packageDir, rootEnvPath).split(path.sep).join("/");
  return `${GENERATED_HEADER}
// @ts-nocheck
/* eslint-disable */
/* prettier-ignore */
/* biome-ignore format: generated file */
/* oxlint-disable */
/// <reference path="${relativePath}" />
`;
}

// ============================================================================
// Package Discovery
// ============================================================================

async function findPackageJsons(dir: string, results: string[] = []): Promise<string[]> {
  const entries = await fs.readdir(dir, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);

    if (entry.isDirectory()) {
      if (entry.name === "node_modules" || entry.name.startsWith(".")) {
        continue;
      }
      await findPackageJsons(fullPath, results);
    } else if (entry.name === "package.json") {
      results.push(fullPath);
    }
  }

  return results;
}

async function readPackageJson(filePath: string): Promise<PackageJson | null> {
  try {
    const content = await fs.readFile(filePath, "utf8");
    return JSON.parse(content);
  } catch {
    return null;
  }
}

async function fileExists(filePath: string): Promise<boolean> {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}

function hasCloudflareTypes(pkg: PackageJson): boolean {
  return !!(pkg.dependencies?.["@cloudflare/workers-types"] || pkg.devDependencies?.["@cloudflare/workers-types"]);
}

// ============================================================================
// Public API
// ============================================================================

export interface GenerateTypesOptions {
  /** Force regeneration even if up to date */
  force?: boolean;
  /** Check only, don't write files */
  check?: boolean;
}

export interface GenerateTypesResult {
  generated: string[];
  skipped: string[];
  upToDate: boolean;
}

const hashRegex = /hash: ([a-f0-9]+)/;
/**
 * Generate lumier-env.d.ts files for type-safe `cloudflare:workers` imports.
 */
export async function generateTypes(
  config: ResourceRegistry,
  rootDir: string,
  options: GenerateTypesOptions = {}
): Promise<GenerateTypesResult> {
  const { force = false, check = false } = options;
  const collected = collectBindings(config);

  if (collected.bindings.size === 0) {
    return { generated: [], skipped: [], upToDate: true };
  }

  const packageJsons = await findPackageJsons(rootDir);
  const rootEnvPath = path.join(rootDir, "lumier-env.d.ts");

  const generated: string[] = [];
  const skipped: string[] = [];
  let allUpToDate = true;

  for (const packageJsonPath of packageJsons) {
    const pkg = await readPackageJson(packageJsonPath);
    if (!pkg) continue;

    const packageDir = path.dirname(packageJsonPath);
    const envPath = path.join(packageDir, "lumier-env.d.ts");
    const relPath = path.relative(rootDir, envPath);

    let content: string;

    if (hasCloudflareTypes(pkg)) {
      content = generateTypesContent(collected, packageDir, true);
    } else if (envPath === rootEnvPath) {
      content = generateTypesContent(collected, packageDir, false);
    } else {
      content = generateReferenceContent(rootEnvPath, packageDir);
    }

    // Check if up to date
    if (!force && (await fileExists(envPath))) {
      const existing = await fs.readFile(envPath, "utf8");
      const existingHash = existing.match(hashRegex)?.[1];
      const newHash = content.match(hashRegex)?.[1];

      if (existingHash && existingHash === newHash) {
        skipped.push(relPath);
        continue;
      }
    }

    allUpToDate = false;

    if (check) {
      continue;
    }

    await fs.writeFile(envPath, content);
    generated.push(relPath);
  }

  return { generated, skipped, upToDate: allUpToDate };
}

/**
 * Generate all types (entry point for CLI)
 */
export async function generateAll(
  config: ResourceRegistry,
  rootDir: string,
  _stateDir: string,
  options: GenerateTypesOptions = {}
): Promise<GenerateTypesResult> {
  return generateTypes(config, rootDir, options);
}
